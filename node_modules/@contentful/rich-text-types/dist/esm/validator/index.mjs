function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _iterable_to_array(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _to_consumable_array(arr) {
    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}
import { BLOCKS } from '../blocks.mjs';
import { INLINES } from '../inlines.mjs';
import { CONTAINERS, LIST_ITEM_BLOCKS, TOP_LEVEL_BLOCKS } from '../schemaConstraints.mjs';
import { ObjectAssertion } from './assert.mjs';
import { HyperLinkAssertion, assert, assertLink, VOID_CONTENT } from './node.mjs';
import { Path } from './path.mjs';
import { assertText } from './text.mjs';
var assertInlineOrText = assert(_to_consumable_array(Object.values(INLINES)).concat([
    'text'
]).sort());
var assertList = assert([
    BLOCKS.LIST_ITEM
]);
var assertVoidEntryLink = assertLink('Entry', VOID_CONTENT);
var assertTableCell = assert(function() {
    return {
        nodeTypes: [
            BLOCKS.PARAGRAPH
        ],
        min: 1
    };
}, function(data, path) {
    var $ = new ObjectAssertion(data, path);
    $.noAdditionalProperties([
        'colspan',
        'rowspan'
    ]);
    $.number('colspan', true);
    $.number('rowspan', true);
    return $.errors;
});
var _obj;
var nodeValidator = (_obj = {}, _define_property(_obj, BLOCKS.DOCUMENT, assert(TOP_LEVEL_BLOCKS)), _define_property(_obj, BLOCKS.PARAGRAPH, assertInlineOrText), _define_property(_obj, BLOCKS.HEADING_1, assertInlineOrText), _define_property(_obj, BLOCKS.HEADING_2, assertInlineOrText), _define_property(_obj, BLOCKS.HEADING_3, assertInlineOrText), _define_property(_obj, BLOCKS.HEADING_4, assertInlineOrText), _define_property(_obj, BLOCKS.HEADING_5, assertInlineOrText), _define_property(_obj, BLOCKS.HEADING_6, assertInlineOrText), _define_property(_obj, BLOCKS.QUOTE, assert(CONTAINERS[BLOCKS.QUOTE])), _define_property(_obj, BLOCKS.EMBEDDED_ENTRY, assertVoidEntryLink), _define_property(_obj, BLOCKS.EMBEDDED_ASSET, assertLink('Asset', VOID_CONTENT)), _define_property(_obj, BLOCKS.EMBEDDED_RESOURCE, assertLink('Contentful:Entry', VOID_CONTENT)), _define_property(_obj, BLOCKS.HR, assert(VOID_CONTENT)), _define_property(_obj, BLOCKS.OL_LIST, assertList), _define_property(_obj, BLOCKS.UL_LIST, assertList), _define_property(_obj, BLOCKS.LIST_ITEM, assert(_to_consumable_array(LIST_ITEM_BLOCKS).sort())), _define_property(_obj, BLOCKS.TABLE, assert(function() {
    return {
        nodeTypes: [
            BLOCKS.TABLE_ROW
        ],
        min: 1
    };
})), _define_property(_obj, BLOCKS.TABLE_ROW, assert(function() {
    return {
        nodeTypes: [
            BLOCKS.TABLE_CELL,
            BLOCKS.TABLE_HEADER_CELL
        ],
        min: 1
    };
})), _define_property(_obj, BLOCKS.TABLE_CELL, assertTableCell), _define_property(_obj, BLOCKS.TABLE_HEADER_CELL, assertTableCell), _define_property(_obj, INLINES.HYPERLINK, new HyperLinkAssertion()), _define_property(_obj, INLINES.EMBEDDED_ENTRY, assertVoidEntryLink), _define_property(_obj, INLINES.EMBEDDED_RESOURCE, assertLink('Contentful:Entry', VOID_CONTENT)), _define_property(_obj, INLINES.ENTRY_HYPERLINK, assertLink('Entry', [
    'text'
])), _define_property(_obj, INLINES.ASSET_HYPERLINK, assertLink('Asset', [
    'text'
])), _define_property(_obj, INLINES.RESOURCE_HYPERLINK, assertLink('Contentful:Entry', [
    'text'
])), _obj);
function validateNode(node, path) {
    if (node.nodeType === 'text') {
        return assertText(node, path);
    }
    var errors = nodeValidator[node.nodeType].assert(node, path);
    if (errors.length > 0) {
        return errors;
    }
    var $ = new ObjectAssertion(node, path);
    $.each('content', function(item, path) {
        return validateNode(item, path);
    });
    return $.errors;
}
export var validateRichTextDocument = function(document) {
    var path = new Path();
    var $ = new ObjectAssertion(document, path);
    if ($.object()) {
        $.enum('nodeType', [
            BLOCKS.DOCUMENT
        ]);
    }
    if ($.errors.length > 0) {
        return $.errors;
    }
    return validateNode(document, path);
};
