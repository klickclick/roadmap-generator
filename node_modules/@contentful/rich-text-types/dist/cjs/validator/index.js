"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "validateRichTextDocument", {
    enumerable: true,
    get: function() {
        return validateRichTextDocument;
    }
});
var _blocks = require("../blocks.js");
var _inlines = require("../inlines.js");
var _schemaConstraints = require("../schemaConstraints.js");
var _assert = require("./assert.js");
var _node = require("./node.js");
var _path = require("./path.js");
var _text = require("./text.js");
function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _iterable_to_array(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _to_consumable_array(arr) {
    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}
var assertInlineOrText = (0, _node.assert)(_to_consumable_array(Object.values(_inlines.INLINES)).concat([
    'text'
]).sort());
var assertList = (0, _node.assert)([
    _blocks.BLOCKS.LIST_ITEM
]);
var assertVoidEntryLink = (0, _node.assertLink)('Entry', _node.VOID_CONTENT);
var assertTableCell = (0, _node.assert)(function() {
    return {
        nodeTypes: [
            _blocks.BLOCKS.PARAGRAPH
        ],
        min: 1
    };
}, function(data, path) {
    var $ = new _assert.ObjectAssertion(data, path);
    $.noAdditionalProperties([
        'colspan',
        'rowspan'
    ]);
    $.number('colspan', true);
    $.number('rowspan', true);
    return $.errors;
});
var _obj;
var nodeValidator = (_obj = {}, _define_property(_obj, _blocks.BLOCKS.DOCUMENT, (0, _node.assert)(_schemaConstraints.TOP_LEVEL_BLOCKS)), _define_property(_obj, _blocks.BLOCKS.PARAGRAPH, assertInlineOrText), _define_property(_obj, _blocks.BLOCKS.HEADING_1, assertInlineOrText), _define_property(_obj, _blocks.BLOCKS.HEADING_2, assertInlineOrText), _define_property(_obj, _blocks.BLOCKS.HEADING_3, assertInlineOrText), _define_property(_obj, _blocks.BLOCKS.HEADING_4, assertInlineOrText), _define_property(_obj, _blocks.BLOCKS.HEADING_5, assertInlineOrText), _define_property(_obj, _blocks.BLOCKS.HEADING_6, assertInlineOrText), _define_property(_obj, _blocks.BLOCKS.QUOTE, (0, _node.assert)(_schemaConstraints.CONTAINERS[_blocks.BLOCKS.QUOTE])), _define_property(_obj, _blocks.BLOCKS.EMBEDDED_ENTRY, assertVoidEntryLink), _define_property(_obj, _blocks.BLOCKS.EMBEDDED_ASSET, (0, _node.assertLink)('Asset', _node.VOID_CONTENT)), _define_property(_obj, _blocks.BLOCKS.EMBEDDED_RESOURCE, (0, _node.assertLink)('Contentful:Entry', _node.VOID_CONTENT)), _define_property(_obj, _blocks.BLOCKS.HR, (0, _node.assert)(_node.VOID_CONTENT)), _define_property(_obj, _blocks.BLOCKS.OL_LIST, assertList), _define_property(_obj, _blocks.BLOCKS.UL_LIST, assertList), _define_property(_obj, _blocks.BLOCKS.LIST_ITEM, (0, _node.assert)(_to_consumable_array(_schemaConstraints.LIST_ITEM_BLOCKS).sort())), _define_property(_obj, _blocks.BLOCKS.TABLE, (0, _node.assert)(function() {
    return {
        nodeTypes: [
            _blocks.BLOCKS.TABLE_ROW
        ],
        min: 1
    };
})), _define_property(_obj, _blocks.BLOCKS.TABLE_ROW, (0, _node.assert)(function() {
    return {
        nodeTypes: [
            _blocks.BLOCKS.TABLE_CELL,
            _blocks.BLOCKS.TABLE_HEADER_CELL
        ],
        min: 1
    };
})), _define_property(_obj, _blocks.BLOCKS.TABLE_CELL, assertTableCell), _define_property(_obj, _blocks.BLOCKS.TABLE_HEADER_CELL, assertTableCell), _define_property(_obj, _inlines.INLINES.HYPERLINK, new _node.HyperLinkAssertion()), _define_property(_obj, _inlines.INLINES.EMBEDDED_ENTRY, assertVoidEntryLink), _define_property(_obj, _inlines.INLINES.EMBEDDED_RESOURCE, (0, _node.assertLink)('Contentful:Entry', _node.VOID_CONTENT)), _define_property(_obj, _inlines.INLINES.ENTRY_HYPERLINK, (0, _node.assertLink)('Entry', [
    'text'
])), _define_property(_obj, _inlines.INLINES.ASSET_HYPERLINK, (0, _node.assertLink)('Asset', [
    'text'
])), _define_property(_obj, _inlines.INLINES.RESOURCE_HYPERLINK, (0, _node.assertLink)('Contentful:Entry', [
    'text'
])), _obj);
function validateNode(node, path) {
    if (node.nodeType === 'text') {
        return (0, _text.assertText)(node, path);
    }
    var errors = nodeValidator[node.nodeType].assert(node, path);
    if (errors.length > 0) {
        return errors;
    }
    var $ = new _assert.ObjectAssertion(node, path);
    $.each('content', function(item, path) {
        return validateNode(item, path);
    });
    return $.errors;
}
var validateRichTextDocument = function(document) {
    var path = new _path.Path();
    var $ = new _assert.ObjectAssertion(document, path);
    if ($.object()) {
        $.enum('nodeType', [
            _blocks.BLOCKS.DOCUMENT
        ]);
    }
    if ($.errors.length > 0) {
        return $.errors;
    }
    return validateNode(document, path);
};
